<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="Jan Arends">

    <title>Malware Analysis</title>

    <link rel="stylesheet" type="text/css" href="../../vendor/prism.css">
    <link rel="stylesheet" type="text/css" href="../../mystyle.css">
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Tenor+Sans"/>
</head>

<body>

<header>
    <div class="headerbg"></div>
    <a href="../../index.html">
        <button class="fancy-button">Home</button>
    </a>
    <h1>Malware Analysis</h1>
</header>
            
<div class="paper">
    <main>
    <div>

        <h2>1 Introduction</h2>
        <p>The number of software developed for malicious purpose is still growing. Computer criminals are no longer
            some script kiddies. They’ve become very organized and professional and are highly motivated to gain deep
            knowledge to fulfill their goals. The more complex and intelligent a malware gets the more time consuming is
            the process of analyzing it. Luckily many tools out there has been adapted to handle such complexity. Some
            of them will be introduced shorty later.</p>
        <p>
            The focus of this paper is the brief introduction of basic techniques and entry points to analyze malware.
            An overview of all associated categories isshown in Figure 1. Beginning at the bottom this is the typical
            order an investigator would go through. The higher the entry in the pyramid, the moreknowledge and practice
            is needed to stay efficiently. The fully automated approach is not covered here, since it obviously uses the
            listed techniques. The term reverse engineering is such a massive topic which is why it’s stated separately.
            Technically it belongs to both of the main categories of this paper where it will be covered: The static-
            and the dynamic analysis. They’ll be discussed successively. Associated anti techniques are mentions rarely
            to stay focused. Also, examples are limited to Windows and Linux. </p>


        <div class="center">
            <figure>
                <img class="dark-bg" src="images/analysis-stages.svg">
                <figcaption>Figure 1: Stages of Malware Analysis</figcaption>
            </figure>
        </div>

        <p> Besides, the reader should be aware of the differences between malware analysis and malware detection. Due
            to the fact that software might also be analyzed for detection of maliciousness the techniques of the two
            terms can overlap but the basic idea differs. However, just the analyzing techniques of software which is
            already considered as malicious is covered here. </p>
        <h3>1.1 Incident Response</h3>
        <p> Usually the process of analyzing starts as response to a security incidents e.g. within an organization. To
            respond to and recover from an incident appropriately, the nature and impact of the incident have to be
            explored. Following questions [1] about the malware should be answered in the end of the analyze
            process. </p>
        <ul>
            <li>What type of malware is it?
            <li> What is the intended purpose and how does it accomplish it?
            <li> What is the functionality and capability?
            <li> What affect does it have on the system?
            <li>How does is spread?
        </ul>
        An analyst can’t possibly understand every detail of the malware. The focus should be on the key features [2, p.5].
        <h3>1.2 Lab enviroment</h3>
        <p> Analysis of malware means to work with potential damaging code. Therefor it requires a safe and secure lab
            environment to overcome the risk of damage. To ensure that the code is contained and unable to connect to
            any production system or the internet the program file should be placed on an isolated or ”sandboxed” system
            with a simulated network. Otherwise it can affect the production system which could end in a lot of trouble.
            [1]. It might be worth to take a look at the common Linux distribution REMnux: ”A Linux Toolkit for
            Reverse-Engineering and Analyzing Malware” [3]. </p>
        <h2>2 Static Analysis</h2>
        <p> Let’s begin with static analysis. It’s the process of analyzing an executable binary file without actually
            executing it. It usually the first step in studying malware and necessary to gain enough information about
            the file to categorize it and discuss further steps and techniques [1]. </p>
        <p> But before getting into deeper explanations about analyzing an executable it is worth to recall the way such
            file is created usually. Figure 2 gives an overview of files and components involved. While compiling the
            source code into a binary executable some information (e.g., the size of data structures or variables) gets
            lost. [4]. An executable file itself can still offer various hints about the way it is created. This might
            be important for analysis or later reverse engineering. Tools and techniques which extract Metadata or
            embedded information make this possible an will be discussed in this section. </p>

        <div class="center">
            <figure>
                <img src="images/steps.svg">
                <figcaption>Figure 2: Steps to consider during static analysis</figcaption>
            </figure>
        </div>

        <p> Because the code in the executable is based on the targeted machine language it meant to be processed by a
            machine and isn’t meant to be human readable. This makes the direct analysis of this code impossible.
            However tools and techniques exits to recreate readily code from the binary, e.g. disassembler or
            decompiler. They will be discussed later. </p>
        <p> Due to the time consuming process of analyzing the reverse engineering code, the analysis process sometimes
            reduces the applicable static methods to those that retrieve the information from the binary representation
            of the malware [4]. At least if the analyst has a short and limited time frame. </p>

        <h3>2.1 File Identification</h3>

        <h4>2.1.1 File Formats</h4>

        <p> It’s relevant to identify the file format it is to be analyze to perform a appropriate analysis. Therefore
            file signatures are used. A file signature is a unique sequence of identifying bytes written to a files’
            header. The signatures differ from file type [1, p.394]. To inspect the file signature either a file
            identification tool is used or the binary is reviewed manually using a hexadecimal viewer or editor. Table 1
            shows common file formats for the major platforms the malware analyst has to deal with. </p>

        <table class="center">
            <caption>Table 1: Common File Formats</caption>
            <thead>
            <tr>
                <th>Platform</th>
                <th>Format</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Windows</td>
                <td>Portable Executable</td>
            </tr>
            <tr>
                <td>Linux</td>
                <td>Executable and Linkable Format</td>
            </tr>
            <tr>
                <td>MacOS</td>
                <td>Mach-O</td>
            </tr>
            </tbody>
        </table>

        <h4>2.1.2 Fingerprint</h4>

        <p> To produce a unique hash value of the malicious file is a common technique to start with [2, p.8]. Therefor
            the algorithms MD5 or SHA-1 are used. The hash acts like a fingerprint and is used to identify the file
            within the community. In addition current antivirus software are base on such fingerprints, at least
            partially. Hence it’s also a good step to run the file through multiple antivirus programs. Websites such as
            www.virustotal.com offers to scan the file using multiple antivirus engines. In the end the investigator
            gets indications about weather the file was being analyzed or captured before [2,p.10]. </p>
        <h4>
            2.1.3 Obfuscation</h4>
        <p> Obfuscation is a technique against the analyzing process, also called a anti technique. The code is
            converted to a new different version without affect to the functionality. Hence e.g. fingerprints are
            different. The goal is to make the analyzing process more difficult. A simple example of a obfuscation
            technique is the adding of some ineffective instructions to the program, namely junk code insertion
            [5]. </p>
        <p> With regard to section 3 another technique is worth mention. To go a step further malware authors obfuscates
            the entire file with a program called packer illustrated in Figure 3 from [6]. A packer typically encrypts
            the malware as illustrated in Figure 3 (a). When loaded into memory like in Figure 3 (b) it unpacks itself
            as shown in Figure 3 (c). </p>
        <figure class="center">
            <img src="images/packing.png">
            <figcaption>Figure 3: Packing and unpacking process</figcaption>
        </figure>
        <p> Clearly, it’s important to analyze obfuscation techniques like this to efficiently analyze malware in the
            static process. The detection is possible because although the encrypted part is unique and hence the
            signature is not well known, the decryptor remains constant from generation to generation [5]. This can be
            used as an indicator. To address the shortcoming of detection and static analysis, malware authors uses
            oligomorphic and polymorphic techniques which generates different decryptors [5]. These techniques are also
            addressable, but since it’s loaded in memory it’s rather a step in the dynamic analysis process. Note: A
            high entropy value properly means compression or/and encryption is being used. </p>
        <h3>2.2 Embedded Artifact Extraction</h3>
        <p> The file identification process gives first clues and hints about the malicious file. It can then be a guide
            to choose the next steps which may must be taken before going further, e.g. talk to other analysts or take
            care of obfuscation techniques. Otherwise a great number of other potentially important facts can be
            gathered from the file / binary code itself which will be discussed now. </p>
        <p> An executable can either be statically linked using a linker or dynamically linked during runtime. Dynamic
            linking relies on invoking shared libraries and functions which must be load into the host systems memory,
            to successfully execute. Hence these libraries are refereed to as dependencies. Conversely, statically
            linked executable already contain all functions to successfully execute, therefore don’t have that kind of
            dependencies [1, p.384]. In general all evidences should be inspected separately to have a clear file
            context and to promote organization in the analysis process. Anyway redundant information gathering across
            different analysis entry points is a goodthing. </p>
        <p> During the inspection of embedded entities its handy to have reference web sites available for quick perusal
            [1, p. 316,409]. The following table show typical references for the discussed platforms. </p>

        <table class="center">
            <caption>Table 2: Web references</caption>
            <tr>
                <td> Linux</td>
                <td>
                    <ul>
                        <li>GNU C Library manual
                        <li>The Open Group index of functions
                        <li>Linux man-pages
                    </ul>
                </td>
            </tr>

            <tr>
                <td> Windows</td>
                <td>
                    <ul>
                        <li>Windows API reference
                        <li>Microsoft DLL Help Database
                        <li>TechNet Library
                    </ul>
                </td>
            </tr>
        </table>

        <h4>2.2.1 Strings</h4>
        <p> Usually the code of a malicious file has sequences of characters embedded, namely Strings. They’re
            represented in either ASCII or Unicode format and easy to extract. The tool <code>Strings</code> is often
            the first choice to do so and available for all common platforms. Although Strings has a couple of options
            to choose from, false- positives will properly happen and must be identified manually. Since they don’t
            represent legitimate text they’re obvious to identify [2, p.12]. </p>

        <p>
            The following list shows some examples of what the strings might represent [2] [7]:
        </p>

        <ul>
            <li>Calls to functions, shared libraries and APIs
            <li>Error messages and comments
            <li>Network information
            <li>IRC Channels and C&C Server
            <li>Directory and file names
        </ul>

        <p> After interpreting the strings with the appropriate documentation a first conclusion can be done. The basic
            functionality and potential behavior might be identified. The analyst might already get a feeling about the
            functionality. In the next steps the analyst will properly face the same values, but to double check
            artifacts is a good thing. The fact, that malware authors often plant strings in their code to throw digital
            investigators off track [1, p.316] makes this techniques harder. To plant strings is a fairly common
            technique and is mostly just recognizable through experience. </p>
        <p> Overall it’s still a good way to get an overview of what is in the file. Unless it’s not obfuscated in some
            manner. In that case, a noticeable small amount of strings would be appear and further investigations about
            the packing should be done. </p>        
            
        <h4>2.2.2 Dependecies</h4>
        <p> Most malware is dynamically linked hand hence have dependencies. To know about them is a common and
            important technique and will come across later again. To discover them by identifying shared libraries
            within the string search is a good starting point. Nevertheless additional research has to be done to
            further explore the binary dependencies. Once the dependencies are disclosed they can be looked up in the
            proper documentation. Thus the behavior can be explored. </p>
        <p> Tools to generate a list of all dependencies a file has are available for all common platforms. In a UNIX/
            Linux system the CLI tool <code>ldd</code> is often the first choice. For each dependency, <code>ldd</code>
            displays the location of the matching object and the (hexadecimal) address at which it is loaded [8]. </p>
        <p> The most popular tool for Windows is called <code>Dependency Walker</code>. It provides both a command line
            interface (CLI) and a Graphical user interface (GUI) which offers the investigator a granular perspective
            trough a complete module dependency tree diagram. It lists all required files, all functions that are
            actually called and all those which can be imported from the file [9]. </p>
        <p> Knowing the dependencies allows a good guess about what the program does and is therefore one of the most
            useful pieces of information that can be gathered about an executable during the basic static analysis [2,
            p.15]. </p>        
        <h4>2.2.3 Symbols</h4>
        <p> Symbols are like identifiers for program variables and functions. They’re used for interpreting or debugging
            software. They’re typically stored in a symbol table and like the file dependencies easy to access. Required
            that the author didn’t discarded the symbol information from the file, which is fairly possible. An
            investigator may gain insight into the program’s capabilities from symbols. </p>
        <ul>
            <li>Function name and addresses
            <li>Variable names, addresses, data types and scopes
            <li>Structure and class definitions
        </ul>
        <p> Similarly, if a hostile program is compiled in debug mode it will provide additional information such as
            source code and debugging lines [1, p.290,421]. A structured output of symbol information on Linux offers
            <code>eu-nm</code> utility as part of the <code>elfutils</code> suite. In case the binary is striped the
            symbol table can be further explored by using the <code>eu-readelf</code> utility. To display the symbols
            present in a PE on Windows the program <code>DUMPBIN</code> with a specific argument can be used. </p>
        <h4>2.2.4 Metadata</h4>
        <p> Also an executable file has metadata resides in it and can provide valuable insights of the file. Metadata
            in the context of an executable file can contain information about the origin, ownership, and history of the
            file rather then technical information [1, p.330]. They can be gathered from various parts of the file
            structure. During the creation of an executable like shown in Figure 2, ”including the high-level language
            in which the program was written, the type and version of the compiler and linker used to compile the code,
            and the date and time of compilation”, as well as timestamps, location and previous file names [1,
            p.330]. </p>
        <h3>2.3 Analyzing reversed engineered code</h3>
        <p> Machine code is way too difficult for a human to comprehend. Therefor security analysts often have to resort
            to methods to reverse engineering the code. This could be done either by using a disassembler or a
            decompiler which will be introduces next. The usage is often considered as advanced malware analysis because
            it’s very difficult and time-consuming [10]. </p>        
        <h4>2.3.1 Disassembly code</h4>
        <p> As mentioned earlier, malware samples are mostly just available in binary form at the machine code level.
            However, it’s possible to recover a low-level language code from machine code reliably and consistently [2,
            p.67]. Remember, a low-level language is a human-readable version of a computer architecture’s instruction
            set [2, p.67] The assembly language is the most common of its kind. The code can be generated from a binary
            using a disassembler. </p>
        <p> It’s theoretically a perfect chance to analyze the malicious behavior. But with regards to the high-level
            language the malware in written in, the instructions has a one-to-many relationship to assembly code.
            Meaning that one high-level instruction consists of several low-level instructions [11, p.1]. Hence the
            assembly code is way larger and overall harder to read and understand then the original high level
            representation. Here’s an example from [2, p.116]. Listing 1 shows a for-loop written in C and Listing 2
            shows the disassembled version of that structure: </p>
        <figure>
<pre>
<code class="line-numbers language-python">int i;
for ( i = 0; i < 100;
	 printf (” i equals %d\n”, i)
}
</code>
</pre>
        <figcaption class="figure-caption">Listing 1: For-loop written in C</figcaption>
        </figure>


        <figure>
<pre>
<code class="lang-binary line-numbers">00401004 		mov 	[ebp+var_4], 0
0040100B 		jmp 	short loc_401016
0040100D loc_40100D:
0040100D 		mov 	eax, [ebp+var_4]
00401010 		add 	eax, 1
00401013 		mov 	[ebp+var_4], eax
00401016 loc_401016:
00401016 		cmp 	[ebp+var_4], 64h
0040101A 		jge 	short loc_40102F
0040101C 		mov 	ecx, [ebp+var_4]
0040101F 		push 	ecx
00401020 		push 	offset aID ; "i equals %d\n"
00401025 		call 	printf
0040102A 		add 	esp, 8
0040102D 		jmp 	short loc_40100D
</code>
</pre>
            <figcaption>Listing 2: Assembly code for the for loop example above</figcaption>
        </figure>

        <p>
            To not evaluate every individual assembly instruction it is worth analyzing instructions as groups [2,
            p.109]. Techniques exists to recognize all common high-level constructs such as loops and conditional
            statements. They can be visualized with control flow graph to obtain a high-level picture of the code
            functionality. Figure 4 shows such graph for the for-loop example above. Although the explanation of
            assembly code is out of the scope of this paper, it’s obvious how this visualization can speed up the
            process. </p>
        <figure class="center">
            <img src="images/graphview.png">
            <figcaption>Figure 4: Graph view for the for loop example above</figcaption>
        </figure>
        <p> The state of the art software in this case is <code>IDA</code> from Hex-Rays. It offers a disassembler for a
            large number of processors, code graphing and a hole lot of other features in addition. </p>        <h4>
        2.3.2 Decompiled code</h4>
        <p> To speed up the reverse engineering process decompilers are very important tools. They enable to reason
            about the high-level form of code instead of its low-level assembly form [10]. In addition, while high-level
            abstractions (eg. if-else-statements or loops) are getting lost during compilation a decompiler tries to
            recover these abstractions to analyze the code more easily [12]. </p>
        <p> Although decompilers has been studied over many years and significant advances have been made most
            decompilers produce very complex and unreadable code. Therefor analysts frequently go back to analyzing the
            assembly code [12]. </p>
        <p> In in 2016 and 2017 major improvements has been done. For instants the <code>DREAM</code> Decompiler [10]
            and the extended Version <code>DREAM ++</code> [12]. Also the retargetable Decompiler <code>RetDec</code>
            [13], which was developed by AVG and published by Avast after they bought the company in December 2017,
            looks promising. </p>
        <h2>2 Dynamic Analysis</h2>
        <p> Dynamic analysis is the process of analyzing the malicious software while it’s actually executing. It’s
            usually done right after the static analysis. It can overcome some of the anti techniques which might have
            limited the previous steps like obfuscation. But also the basic behavioral analysis do have their
            limitations, because not all code paths may execute when a piece of malware is run [2, p.40]. In addition,
            also here do anti techniques like monitoring-, virtual machine- or memory capturing detection exist, but as
            mentioned at the beginning, this is out of the scope of this paper. At this point the more advanced dynamic
            analysis, which will be at the end of this section, helps out </p>
        <h3>3.1 Malware characteristics </h3>
        <p> For the later monitoring section a recap of the basic actions might be helpful. In [14] the malware
            characteristics are good summarized. The authors defined basis behavior operation sets which are categorized
            as followed: </p>
        <ul>
            <li>File Actions = {Create, Delete, Read, W rite, Rename}
            <li>Process Actions = {Create, T erninate}
            <li>Network Actions = {TCP, UDP, IP }⊕{Listen, Connect, Send, Recv}
            <li>Registry Actions = {OpenKey, CloseKey, CreateKey} ∧ {SetV alue, DeleteV alue, QueryV alue}
        </ul>
        <p> These are basic actions also a non malicious software would do. But by combining these operations and
            studying the order and relationships between them it becomes more meaningful and significant in the malware
            analysis process. Hence those characteristics are often merged to a signature for official identification
            and detection as well. </p>
        <p> In [14] they defined some of those compositions which an investigator of malware is looking for in the
            dynamic analysis process. Such behavior can be discovered by monitoring the system in different ways. </p>
        <h3>3.2 Monitoring</h3>        <h4>Process and threads</h4>
        <p> A process is a program in execution. Hence it seems to be an obvious step in the dynamic analysis process.
            To explore all the processes related to the malware gives important insights to the functionality. In
            particular the investigator wants to know which processes are running, created or terminated while the
            malware is executing. This gives great indications of the functionality. The investigator might see for
            example if the malware is killing an anti-virus process or which programs the malware loads into
            memory. </p>
        <p> In addition a bunch of other interesting information associated with each process can be displayed and
            analyzed. For example all shared libraries the malware actually loaded, open files and handles or on which
            port the process is listening. </p>
        <p> As tool examples there is the <code>Process Monitor</code> for Windows. It’s also a GUI tool which is used
            to monitor activities related to the next subsections, like registry, file system or networking. In case of
            the process monitoring if also offers a nice timeline for a fast understanding of the processes order of
            appearance. Even the shortest appearance of a process will be visible there. The analysis on a Linux system
            involves tools like <code>htop</code>, an interactive process viewer for all kind of information about
            processes. </p>
        <p> A common anti technique which is worth mention is called ’process replacement’. It involves running a
            process on the system and overwriting its memory space with a malicious executable to provide the malware
            with the same privileges as the process it is replacing [2, p.49]. To overcome this anti technique the
            memory image has to be analyzed. This will be discussed later in section 3.3. </p>        <h4>System or API
        calls</h4>
        <p> Functions that form a coherent set of functionality, such as manipulating files or communicating over the
            network, are often grouped into an API [4,p.7]. They are usually provided by the operating system to perform
            common tasks. The term Windows API refers to a set of APIs that provide access to different functional
            categories, such as networking, security, system services, and management [4, p.7]. </p>
        <p> For the analyzing point of view, system calls are similar. They’re also provided by the operating system as
            a special well-defined API which separate user-mode from kernel-mode. To interact with the system and the
            environment the malware has to invoke system calls since only the kernel-mode has direct access it. Typical
            examples are calls for file modifications or registry changes but also network functionality is provided by
            the operating system via system calls. </p>
        <p> Not just the calls itself are pretty useful, also the tracking of parameters and function return values
            enables insights in a dynamic analysis approach. It enables to identify the the correlation of individual
            function calls that operate on the same object [4, p.9]. </p>
        <p> Overall the identification of all these calls and corresponding parameters it’s a great chance to get
            further knowledge of the behavior. Mainly because APIs and system calls are excellent documented for all
            platforms, see Table 2. </p>        
        <h4>File system and Registry</h4>
        <p> Also important are the file system or registry interactions which are related to the malware processes.
            Since the technique is similar they are discussed here together. Even though they could be identified by
            investigating API or system calls, it’s always best practice to double check, due to the possibility to miss
            important information in previous steps. </p>
        <p> Since malware often adds entries to the registry for persistence or configuration data which e.g. allows the
            malware to run automatically when the computer boots [2, p.172], is a prefect place to look on. Equivalently
            are files the malware uses to store data, like for arrived data from a remote server. To identify both of
            these interactions making and comparing snapshots is the key here. </p>
        <p> On Windows there is an easy to use tool calls <code>Regshot</code> to take two snapshots. An analyzer may
            want to take a snapshot before executing the malware and the second right after it has finished. Which key
            and values were added or modified in the registry during execution can be seen in the results
            <code>Regshot</code> is giving. </p>
        <p> To operate as desired modern malware often requires some form of Internet access. Additional components or
            configuration data might be downloaded [4] via C&ampC or IRC server. To figure out all those activities the
            network traffic is has to be explored and the the protocol has to be reverse-engineered. </p>
        <p> As already mention at the beginning of the paper, a simulated network is the precondition. Commonly used
            network services like DNS, mail, IRC, and file servers has to be simulated, and all traffic has to be
            redirected to these services. If the network is simulating properly the malware will exhibit its malicious
            behavior and the analysis is completely self contained [4]. </p>
        <p> Normally this process is using PCAPs which is an API for recording network traffic between to points in
            time. It’s used by e.g. <code>Wireshark, tcpdump</code> or <code>Bro</code>, which are all commonly used
            tools in network analysis. Hence network communication can already be explored during the API or system call
            mon- itoring process. </p>
        <p> In [15] they stated the importance of network behavior analysis due to the limitations of static and other
            dynamic methods. These limitations are based on attempt to evade detection or analysis of the malware which
            the authors usually have. With regards to the data the malware needs to download to conduct its attack, it
            is difficult to evade network behavior based methods. </p>
        <h3>Memory forensics</h3>
        <p> The powerful analysis of memory enables a deep look into the systems behavior. Every action the operating
            system or an program is taking results in specific modifications to the computer’s memory or RAM. The action
            performed can often persist a long time after it was taken [16, p.XVII]. Additionally, it ”provides
            unprecedented visibility into the runtime state of the system which processes were running, open network
            connections, and recently executed commands” [16, p.XVII]. Besides, critical data often exists exclusively
            in memory, like encryption keys hence unencrypted messages and content. </p>
        <p> Although the inspection of the mentioned entry points can yield compelling evidence, it is often the
            contents of RAM that enables the full reconstruction of events. It provides the necessary puzzle pieces for
            determining what happened before, during, and after an infection by malware or an intrusion by advanced
            threat actors [16, p.XVII]. </p>
        <p> To archive all the benefits two steps are required: </p>
        <ol>
            <li> Memory acquisition
            <li> Memory analysis
        </ol>
        <p> Aacquisition is the process of copying the contents of volatile memory to non-volatile storage [16, p.69].
            It can be done by capturing, dumping or sampling the memory. With regards to the time of acquisition
            multiple approaches exist, e.g. terminating-based interval-based or trigger-based [17]. As usual this
            happens a safe and controlled environment and stored as an memory image file for further investigations on
            another system. Since there’s no possibility to use system APIs when parsing a memory image offline it’s
            possible to also get a look in unallocated data or data which was hidden by the malware [18]. </p>
        <p> In the analysis process itself the list of entry points is incredibly long. Almost everything can be found
            in the memory image. E.g. processes, network, file system or registry artifacts. Even disk artifacts because
            all file actions leave traces in memory. Organizing the data with timelines based on the temporal
            relationships between digital artifacts is a traditionally leveraged technique [16, p.537]. </p>
        <p> The <code>Volatility Framework</code> is a common collection of tool which makes the extraction of all those
            digital artifacts possible. It provides the investigator with a single, cohesive and open source framework
            for all needs. </p>
        <h3>Debugging</h3>
        <p> ”A debugger is a piece of software or hardware used to test or examine the execution of another program”
            [2]. It is usually used for developing or troubleshooting software since it gives insight into what a
            program is doing while it is executing. </p>
        <p> Most software developers are familiar with high level language debuggers but because no high level code is
            available during malware analysis, the use of assembly level debuggers is necessary. These operate
            similarly. The user can step through the instructions, set breakpoints to stop on specific lines of the
            assembly code, and examine memory locations [2, p.168]. </p>
        <p> A debugger has normally two ways to debug a program. Either the user starts the program with the debugger or
            the user attaches the debugger to a program that is already running. The second way is useful to debug a
            process that is affected by the analyzed malware [2, p.169]. </p>
        <p> Beside a debugger has a couple of functions necessary to know for the analysis process. First the
            single-stepping. It’s not recommended to step through every single instruction in the entire program. To be
            selective about the code to analysis is more efficient. Furthermore to decide whether to step-over a
            function call or to step-in the function has to be reasonable. To step-over wrong function could end up
            missing important functionality while stepping into a function significantly increase the amount of
            instructions needed to be analyzed. Last but not least the pausing function using breakpoints. These allow
            the user to examine a program’s state [2, p.169f.]. A common x86 debugger for malware analysis is the easy
            to use and plug-in rich <code>OllyDbg</code>. </p>
        <h2>Conclusion</h2>
        <h3>Summary</h3>
        <p> A lot of techniques, tools and entry points for the process of analyzing malware are now introduced. To
            perform basic static analysis it’s possible to gain a certain amount of insight into the functionalities,
            using a suite of relatively simple tools [2, p.26]. To become really successful in the end of the process
            more advanced techniques, like usage of a debugger, is needed. A working knowledge of assembly and the
            disassembly process is the key here. This can just be gained by practice [2, p.85]. </p>
        <p> The next step is to run the malware during dynamic analysis where thefind ings from the basic static
            analysis can be confirmed or confuted. As for the static approach also the dynmaic is divided into basic and
            advanced levels. The basic analysis is mainly to monitor the systems interactions. For more and detailed
            information of the runtime state of the system investigations of the computers memory can be done. The use
            of a debugger might be easier and is also a very common techniques to analyze malware. </p>
        <h3>Prospect for the future</h3>
        <p> Overall it will always be a race between malware authors and analysts. Anti techniques will get even
            smarter, but detection of those as well. However the growing research of this topic will show where the
            analysis process will go. The fully automated approach might be satisfying for all kinds of malware in the
            near future. The artificial intelligence, deep learning and neural networks could assist to reach this
            goal. </p>
        <h2>References</h2>
            <div class="table">
        <table>
            <thead>
            <tr>
                <th>Abbrev</th>
                <th>Source</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <th scope="row">[1]</th>
                <td> C.H. Malin, E. Casey, and J.M. Aquilina. Malware Forensics: Investi-
                    gating and Analyzing Malicious Code. Elsevier Science, 2008.
                </td>
            </tr>

            <tr>
                <th scope="row">[2]</th>
                <td>M. Sikorski and A. Honig. Practical Malware Analysis: A Hands-On
                    Guide to Dissecting Malicious Software. No Starch Press, 2012.
                </td>
            </tr>

            <tr>
                <th scope="row">[3]</th>
                <td>REMux. www.remnux.org/ .</td>
            </tr>

            <tr>
                <th scope="row">[4]</th>
                <td>E. Kirda M. Egele, T. Scholte and C. Kruegel. A Survey on Automated
                    Dynamic Malware-Analysis Techniques and Tools. ACM Computing
                    Surveys, Vol. 44. ss, 2012.
                </td>
            </tr>

            <tr>
                <th scope="row">[5]</th>
                <td> I. You and K. Yim. Malware obfuscation techniques: A brief survey.
                    In International Conference on Broadband, Wireless Computing, Com-
                    munication and Applications, 2010.
                </td>
            </tr>

            <tr>
                <th scope="row">[6]</th>
                <td> G. Yuxin, L. Zexin, and L. Yuqing. Survey on malware anti analysis. In
                    Fifth International Conference on Intelligent Control and Information
                    Processing, 2014.
                </td>
            </tr>

            <tr>
                <th scope="row">[7]</th>
                <td>D. Distler. Malware Analysis: An Introduction. SANS Institute, 2007.</td>
            </tr>

            <tr>
                <th scope="row">[8]</th>
                <td> M. Kerrisk. Linux Manual Page: ldd(1). https://www.kernel.org/doc/
                    man-pages/ , September 2017.
                </td>
            </tr>

            <tr>
                <th scope="row">[9]</th>
                <td> Dependency Walker: Using Dependency Walker for General Informa-
                    tion about Modules. www.dependencywalker.com/help/html/overview_3.htm .
                </td>
            </tr>

            <tr>
                <th scope="row">[10]</th>
                <td> K. Yakdan, S. Eschweiler, E. Gerhards-Padilla, and M. Smith. No more
                    gotos: Decompilation using pattern-independent control-flow structur-
                    ing and semantics-preserving transformations. In ??, 2015.
                </td>
            </tr>

            <tr>
                <th scope="row">[11]</th>
                <td> James T. Streib. Guide to Assembly Language - A Concise Introduction.
                    Springer, 2011.
                </td>
            </tr>

            <tr>
                <th scope="row">[12]</th>
                <td> K. Yakdan, S. Dechand, E. Gerhards-Padilla, and M. Smith. Helping
                    johnny to analyze malware: A usability-optimized decompiler and mal-
                    ware analysis user study. In 2016 IEEE Symposium on Security and
                    Privacy, 2016.
                </td>
            </tr>

            <tr>
                <th scope="row">[13]</th>
                <td> Avast Software. Retargetable Decompiler RetDec. https://retdec.com/ ,
                    December 2017.
                </td>
            </tr>

            <tr>
                <th scope="row">[14]</th>
                <td> P. Ren, Liu W., Sun D., Wu J., and Liu K. Analysis and forensics
                    for behavior characteristics of malware in internet. In 14th Annual
                    Conference on Privacy, Security and Trust (PST), 2016.
                </td>
            </tr>

            <tr>
                <th scope="row">[15]</th>
                <td> T. Shibahara, T. Yagi, M. Akiyama, D. Chiba, and Takeshi Yada. Effi-
                    cient dynamic malware analysis based on network behavior using deep
                    learning. In 2016 IEEE Global Communications Conference (GLOBE-
                    COM), 2016.
                </td>
            </tr>

            <tr>
                <th scope="row">[16]</th>
                <td> M. Hale Ligh, A. Case, J. Levy, and A. Walters. The Art of Memory
                    Forensics: Detecting Malware and Threats in Windows, Linux, and
                    Mac Memory. John Wiley & Sons, Inc., 2014.
                </td>
            </tr>

            <tr>
                <th scope="row">[17]</th>
                <td>T. Teller and A. Hayon. Enhancing automated malware analysis ma-
                    chines with memory analysis. BlackHat, 2014.
                </td>
            </tr>

            <tr>
                <th scope="row">[18]</th>
                <td>T. Haruyama and H. Suzuki. One byte Modification for Breaking Mem-
                    ory Forensic Analysis. https://media.blackhat.com/bh-eu-12/Haruyama/
                    bh-eu-12-Haruyama-Memory_Forensic-Slides.pdf , 2012.
                </td>
            </tr>

            </tbody>
        </table>
    </div>
    </div>

</main>
</div>
<script src="../../vendor/prism.js"></script>
</body>
</html>